%!TEX root = ../dissertation.tex
\externaldocument{../frontmatter/abbr}
\externaldocument{./chapter1}
\begin{savequote}[75mm]
Nulla facilisi. In vel sem. Morbi id urna in diam dignissim feugiat. Proin molestie tortor eu velit. Aliquam erat volutpat. Nullam ultrices, diam tempus vulputate egestas, eros pede varius leo.
\qauthor{Quoteauthor Lastname}
\end{savequote}

\chapter{Progettazione}
\section{Panoramica}
La natura di questo prodotto come parte di un ecosistema esistente e già affermato ha avuto un duplice effetto sulla fase di progettazione. Da un lato l'ha resa più semplice, potendo appoggiarsi a codice preesistente e sfruttando meccanismi e servizi già pronti all''uso come le funzionalità di autenticazione (basate sulla gemma Devise) e il \textit{mailer} configurato; dall'altro, tuttavia, ha fatto emergere diverse sfide nell'integrazione del codice necessario per implementare nuove funzionalità con il \textit{codebase} presente. L'applicazione condivide infatti buona parte della struttura di base con un altro applicativo dell'ecosistema, ed è quindi stata progettata per essere implementata in modo compatibile a quest'ultimo - un esempio è l'aggiunta di domande a risposta multipla ai questionari, che ha comportato un notevole \textit{refactoring} del codice dedicato.
In questa sezione verrà presentata l'architettura generale dell'applicazione, inclusi i paradigmi su cui si fonda, e verranno descritte le sue parti fondamentali. Ove queste parti si sovrappongano all'architettura preesistente, verranno indicate le eventuali aggiunte o modifiche apportate nello corso della progettazione.

\subsection{Progettare con Rails}
Come anticipato nella sezione \hyperref[sec:2.2.3]{2.2.3}, l'utilizzo di Ruby on Rails comporta il seguire certi paradigmi nella scelta dell'architettura e nella progettazione di un'applicazione. Progettare con Rails è sicuramente stata un'esperienza molto diversa rispetto all'utilizzo di altri framework, per via della sua natura altamente integrata che guida la progettazione verso un certo stile: le applicazioni sviluppate con Rails sono fortemente orientate ad uno stile architetturale ``\textit{\ref{itm:rest}-like}'', in cui la \textit{business logic} e il database sono fortemente accoppiati in \textit{models} che costituiscono le risorse; tali risorse sono quindi gestite attraverso dei \textit{controllers}, le cui operazioni sono rese accessibili attraverso \textit{endpoint} specificati nel file di \textit{routing}, e rese visibili grazie alle \textit{views} associate ai \textit{controllers}.

Altre peculiarità di Rails risiede nel fatto che, per lo stesso motivo, il classico paradigma di ereditarietà della programmazione ad oggetti non risulta ottimale per l'implementazione dei \textit{models} che sono al cuore della \textit{business logic} dell'applicativo: essendo tali classi convenzionalmente associate a tabelle del database, la loro progettazione deve tenere conto dell'aumento di complessità del database che sarebbe dovuto all'applicazione di classici \textit{design pattern}. Spesso quindi è preferibile aggiungere direttamente campi (e relativi metodi) ad un \textit{model} ed usare questi per differenziarne il comportamento in situazioni diverse. È il caso, come verrà spiegato più avanti, dei modelli che rappresentano gli esami: creare un nuovo modello per supportare gli esami in ``Biota'', separato da quello preesistente, avrebbe aumentato inutilmente la complessità del database (in quanto la maggior parte dei campi sono condivisi, risultando in due tabelle quasi identiche); avrebbe inoltre comportato la duplicazione delle query GraphQL necessarie. Sono invece stati aggiunti i campi necessari al modello esistente, grazie alla presenza di un campo \texttt{service} che agisce da discriminante sull'applicazione cui appartiene un determinato esame.

\section{Architettura}
L'architettura di ``Biota'' si è necessariamente dovuta conformare a quella della piattaforma preesistente di cui fa parte, adottando uno stile \textit{\ref{itm:rest}-like} e implementando un pattern MVC. Come menzionato nella sezione \hyperref[sec:devctx]{2.1.1}, l'applicazione è articolata in un \textit{back end} e un \textit{front end} sviluppati separatamente, in accordo allo stile \ref{itm:rest} che prevede la separazione di interfaccia utente e risorse. Il \textit{back end} è stato progettato implementando un pattern MVC con uno stile architetturale \ref{itm:rest}; l'interazione tra \textit{back end} e \textit{front end} è permessa dall'utilizzo di \ref{itm:api} GraphQL attraverso cui il \textit{back end} espone varie operazioni di visualizzazione, creazione, modifica ed eliminazione delle risorse. Sebbene normalmente il paradigma \ref{itm:rest} si basi direttamente sul protocollo \ref{itm:http}, l'utilizzo di GraphQL permette la progettazione di una \ref{itm:api} più versatile facilitando il reperimento di informazioni. Viene inoltre resa disponibile una classica \ref{itm:api} \ref{itm:http} per l'interazione con il software gestionale del laboratorio di analisi. Entrambe le \ref{itm:api} sono progettate in modo da garantire la sicurezza, richiedendo che le richieste siano autenticate con diverse modalità. 

La gestione manuale delle risorse è possibile attraverso un pannello di amministrazione dedicato, anch'esso realizzato secondo uno stile \textit{\ref{itm:rest}-like}. Una piccola variazione rispetto a questo stile è rappresentata dalle interazioni con il servizio esterno Amazon \ref{itm:sns} e le \ref{itm:api} del corriere SDA, che sono gestite da servizi dedicati in forma di \textit{client} ad-hoc istanziati ed eseguiti dal \textit{back end}, prendendo spunto dallo stile architetturale a micro-servizi.

\subsection{Representational State Transfer}
Il paradigma architetturale principale, già menzionato più volte, è \ref{itm:rest}, acronimo di \textit{Representational State Transfer}; esso è uno degli stili architetturali più utilizzati nella progettazione di servizi Web grazie alla caratteristica di snellire lo scambio di informazioni su cui essi si basano.

Un sistema \ref{itm:rest}ful si compone di due parti: un \textbf{client} che richiede delle risorse e un \textbf{server} che possiede e gestisce tali risorse. Il client ed il server comunicano attraverso una apposita interfaccia detta \ref{itm:api} che implementa un protocollo di comunicazione tra le due entità e permette l'invio di richieste da parte del client, e l'invio di risorse da parte del server.

L'elemento fondamentale dello stile \ref{itm:rest} sono le risorse, unità di informazione basilari identificate univocamente da un \ref{itm:url} che assomigliano, in un certo senso, ai classici oggetti alla base dell'\textit{object-oriented programming}. Le risorse risiedono sul server e sono soggette a quattro tipi di operazioni, note come \textit{\ref{itm:crud}} (\textit{Create, Read, Update, Delete}):
\begin{itemize}
    \item \textbf{Create}: crea una nuova risorsa;
    \item \textbf{Read}: rende disponibile una rappresentazione della risorsa;
    \item \textbf{Update}: modifica il valore della risorsa;
    \item \textbf{Delete}: rende la risorsa inaccessibile.
\end{itemize}

L'accesso alle risorse avviene esclusivamente attraverso queste operazioni, che possono essere ridefinite ed adattate secondo le necessità del client: ad esempio, diverse implementazioni di \textit{read} possono restituire diverse rappresentazioni della stessa risorsa.

Nell'applicazione le risorse sono costituite da record del database descritte da classi dette \textit{models}, che ne danno una rappresentazione interna e contengono la relativa \textit{business logic} in forma di metodi.

\subsubsection{GraphQL e \ref{itm:http}}
La principale differenza che l'applicazione presenta rispetto ai classici sistemi \ref{itm:rest} è l'utilizzo di GraphQL anziché \ref{itm:http} per l'implementazione dell'\ref{itm:api} di comunicazione con in \textit{front end}. Il protocollo \ref{itm:http}, utilizzato come standard nella progettazione di servizi Web con architettura \ref{itm:rest}, prevede 4 metodi per il trasferimento dei dati tra client e server che corrispondono alle 4 operazioni \ref{itm:crud}:
\begin{table}[h]
\begin{center}
    \begin{tabular}{|c||c|}
      \hline % linea orizzontale
      \hspace{5pt}\textbf{Metodo}\hspace{5pt} & \textbf{Operazione}  \\\hline\hline
      POST & Create \cr\hline
      GET & Read \cr\hline
      PUT  & Update \cr\hline
      DELETE &  Delete \cr\hline
    \end{tabular}
    \caption{Corrispondenza tra metodi HTTP e operazioni CRUD.}
    \label{tab:httpcrud}
\end{center}
\end{table}
La rappresentazione delle risorse avviene normalmente attraverso lo standard \ref{itm:json} come parte del \textit{body} di una richiesta o risposta.
Il client invia una richiesta al server utilizzando uno di questi metodi a un \textit{endpoint} esposto dal server, che interpreta la richiesta e risponde di conseguenza; la struttura dei dati restituiti da ogni endpoint è fissata (la rappresentazione della risorsa è legata alla richiesta), quindi rappresentazioni anche parzialmente diverse delle risorse richiederanno \textit{endpoint} diversi.

In GraphQL viene definito uno \textbf{schema} di tipi \textit{server-side}, che descrive le risorse disponibili e le operazioni che è possibile eseguire su di esse. Le operazione si dividono in due categorie: \textit{queries}, corrispondenti all'operazione \textit{create}, e \textit{mutations}, che raggruppano le operazioni di \textit{create, update} e \textit{delete}. Le richieste GraphQL vengono inviate tramite protocollo \ref{itm:http} ad un \textit{endpoint} apposito esposto dal server, e quindi vengono gestite dal componente \textit{run-time}. 
 
Nell'operazione di ottenimento dei dati il client può inviare \textit{query} diverse allo stesso \textit{endpoint}: in questo modo, con una \textit{query} appropriata, il client può ottenere esattamente i dati necessari risolvendo i problemi di \textit{overfetching} e \textit{underfetching} caratteristici dello stile \ref{itm:rest}. GraphQL mantiene il concetto di risorsa, l'invio di richieste mediante il protocollo \ref{itm:http} e l'utilizzo dello standard \ref{itm:json}; tuttavia separa la rappresentazione della risorsa dal metodo per ottenerla, permettendo al client di richiedere esattamente le informazioni necessarie.

\subsection{Implementazione dello stile \ref{itm:rest}}
Lo stile architetturale appena descritto, che riguarda l'intera piattaforma, è implementato  nel seguente modo:
\begin{itemize}
    \item \textsc{\textbf{Server}}: Il server corrisponde al \textit{back end} sviluppato, che gestisce le risorse e risponde alle richieste dei client. Le risorse sono i record salvati nel database PostgreSQL del server, rappresentati come \textit{models}, classi di oggetti realizzate utilizzando il modulo \textbf{ActiveRecord} di Rails. ActiveRecord facilita la gestione \textit{\ref{itm:rest}ful} delle risorse implementando metodi appositi per i \textit{models} le corrispondenti operazioni \ref{itm:crud}.
    \item \textsc{\textbf{API}}: Il server mette a disposizione due \ref{itm:api}, una GraphQL e una HTTP. Le richieste provenienti dall'\textit{endpoint} dedicato a GraphQL sono interpretate dal \textit{runtime system} di GraphQL e gestite secondo il sistema di tipi definito; le richieste \ref{itm:http} sono reindirizzate al corrispondente metodo del controller dedicato secondo quanto definito nel file di \textit{routing}.
    \item \textsc{\textbf{Client}}: 
    \begin{enumerate}
        \item Il \textit{front end} dell'applicazione interagisce tramite l'\ref{itm:api} GraphQL per svolgere le operazioni necessarie all'utilizzo dell'applicazione; l'utilizzo di GraphQL permette di al server di fornire esattamente le informazioni richieste, qualità utile all'interfaccia utente che spesso non ha bisogno dell'intero record. Solo la generazione del report avviene tramite una richiesta \ref{itm:http}, in quanto è necessario restituire soltanto il documento generato.
        \item Il software gestionale del laboratorio di analisi invece effettua richieste \ref{itm:http} presso degli \textit{endpoint} appositi; la scelta di usare il protocollo \ref{itm:http} è dovuta sia al supporto più diffuso, trattandosi di un servizio esterno, che al fatto che questo client necessita sempre dello stesso tipo di rappresentazione delle risorse. 
    \end{enumerate} 
\end{itemize}
\vspace{-20pt}
\subsection{Model, View, Controller}
Il pattern architetturale adottato per la progettazione del \textit{back end}, in accordo all'architettura preesistente e alle convenzioni di Rails, è di tipo \ref{itm:mvc}. Esso è tradizionalmente utilizzato per lo sviluppo di applicativi desktop con interfaccia grafica, ma risulta molto popolare anche per lo sviluppo di applicazioni web. Il pattern \ref{itm:mvc} prevede di separare della logica dell'applicativo software in tre componenti interconnessi:
\begin{itemize}
    \item \textsc{\textbf{Model}}: componente centrale del pattern che contiene la \textit{business logic}, ovvero le regole di accesso e manipolazione dei dati su cui lavora l'applicativo; è costituito, generalmente, dalle rappresentazioni interne dei dati e dai metodi che riguardano tali rappresentazioni.
    \item \textsc{\textbf{View}}: componente corrispondente all'interfaccia dell'applicativo, si occupa di rendere visibili all'utente i dati e le operazioni permesse; contiene i vari elementi grafici dell'interfaccia e le rappresentazioni esterne dei dati.
    \item \textsc{\textbf{Controller}}: componente che contiene la \textit{application logic}: accetta gli input immessi dall'utente tramite la \textbf{view}, gli elabora in operazioni da richiedere al \textbf{model} e restituisce un output che viene visualizzato sempre dalla \textbf{view}.
\end{itemize}

\subsection{Implementazione del pattern \ref{itm:mvc}}
Il pattern architetturale \ref{itm:mvc} viene implementato nella progettazione dell'applicativo nel modo seguente (N.B.: da qui, \textbf{\{model/view/controller\}} si riferisce rispettivo al componente del pattern \ref{itm:mvc}, mentre \textit{\{model/view/controller\}} si riferisce alla rispettiva classe di oggetti).

\subsubsection{Model}
Il \textbf{model} è costituito dall'insieme dei \textit{models} Active Record. Active Record è un modulo di Rails dedicato all'implementazione del \textbf{model} di un'applicazione sfruttando la tecnica detta \textit{Object Relational Mapping}, che permette di connettere classi di oggetti di un'applicazione a tabelle in un database relazionale. Usando tale tecnica le proprietà e relazioni degli oggetti dell'applicazione possono essere conservate nel e lette dal database senza dover impiegare comandi SQL.

Ogni \textit{model} è associato ad una tabella del database convenzionalmente attraverso il nome, che è la versione singolare del nome della tabella (e.g. il \textit{model} \texttt{User} è automaticamente associato alla tabella \texttt{users}); ogni istanza di un \textit{model} rappresenta una riga della tabella. Le relazioni tra tabelle sono esplicitate mediante metodi speciali, detti \textit{associations}, nei modelli interessati.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|c||c|}
        \hline % linea orizzontale
        \hspace{5pt}\textbf{Active Record}\hspace{5pt} & \textbf{Database}  \\\hline\hline
        \textit{model} & Tabella \cr\hline
        Attributo & Colonna \cr\hline
        Istanza di un \textit{model} & Riga \cr\hline
        \textit{Association} & Relazione \cr\hline
        \end{tabular}
        \caption{Corrispondenza tra Active Record e database.}
        \label{tab:modeldb}
    \end{center}
\end{table}

Gli attributi di un \textit{model} sono automaticamente fatti corrispondere alle colonne della tabella, sempre attraverso la nomenclatura; sui valori di tali attributi sono attivi i vincoli imposti a database, più ulteriori vincoli definiti nel \textit{model} nella forma di metodi di validazione: al salvataggio di una nuova istanza di un \textit{model}, verrà prima validato secondo i metodi specificati, e poi validato a database; un fallimento in uno dei due processi di verifica ne previene la scrittura a database. 
I \textit{model} accentrano anche tutta la \textit{business logic} dell'applicativo: tutti i metodi relativi alla manipolazione dei dati di un certo tipo di oggetto vanno inseriti nel corrispettivo \textit{model}.

\subsubsection{Controller}
Il \textbf{controller} è costituito dall'insieme dei \textit{controllers} definiti con Active Controller. Active Controller è un modulo di Rails che permette di applicare il principio \ref{itm:coc} alla creazione di controller per l'applicazione. In generale un \textit{controller} riceve una richiesta \ref{itm:http}, esegue il proprio metodo corrispondente all'interazione desiderata con il \textbf{model} e usa una \textit{view} per creare un output. La corrispondenza tra ciascun \textit{endpoint}, \textit{controller} e metodo del \textit{controller} viene semplicemente specificata all'interno di uno speciale file di \textit{routing}; il resto della configurazione è trasparente allo sviluppatore. La progettazione dell'applicativo prevede un \textit{controller} per ogni attore esterno.

\subsubsection{View}
La \textbf{view} è costituita dall'insieme delle \textit{views} definite tramite la libreria Jbuilder. Jbuilder permette di definire una struttura dati \ref{itm:json} generale all'interno, che può quindi essere ``riempita'' con i dati necessari di volta in volta. Tali \textit{view} vengono utilizzate come \textit{body} delle risposte \ref{itm:http} date dal \textbf{controller} in seguito all'elaborazione di una richiesta, e contengono le informazioni richieste in un formato concordato con il destinatario.
\section{Struttura dell'applicazione}
% \section{Database}
% \subsubsection{Migrations}
% \section{Models}
% \section{Views}
% \section{Controllers}
% \section{API GraphQL}
% \subsection{Types}
% \subsection{Queries}
% \subsection{Mutations}
% \section{API \ref{itm:http}}
% \subsection{Routes}
% \section{Services}
% \subsection{Gestione dei codici OTP}
% \subsection{Client per Amazon SNS}
% \subsection{Client per API di SDA}
% \subsection{Logger}


